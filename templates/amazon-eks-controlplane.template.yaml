# The Amazon EKS controlplane template was copied and customized to support
# custom node roles. See `Cisco -` comments in the template to see the changes.
# The issue is opened on "quickstart-amazon-eks" repo: https://github.com/aws-quickstart/quickstart-amazon-eks/issues/299

AWSTemplateFormatVersion: "2010-09-09"
Description: "Deploys the EKS control plane (qs-1p7nknofn)"
#Transform: [QuickStartParameterResolver]
Metadata:
  QSLint:
    Exclusions: [W9002, W9003, W9004, W9006]
  #ConfigSetName: !Ref ConfigSetName
Parameters:
  # Cisco - custom node role support
  CustomNodeRole:
    Type: String
    Default: ""
  # end
  SecurityGroupIds:
    Type: List<AWS::EC2::SecurityGroup::Id>
  SubnetIds:
    Type: List<AWS::EC2::Subnet::Id>
  RoleArn:
    Type: String
  AdditionalEKSAdminUserArn:
    Type: String
    Default: ""
  AdditionalEKSAdminRoleArn:
    Type: String
    Default: ""
  KubernetesVersion:
    Type: String
    Default: ""
  BastionRole:
    Type: String
    Default: ""
  FunctionRoleArn:
    Type: String
  EKSPublicAccessCIDRs:
    Type: List<String>
    Default: 0.0.0.0/0
  EKSPublicAccessEndpoint:
    Type: String
    AllowedValues: [Enabled, Disabled]
    Default: Disabled
  EKSPrivateAccessEndpoint:
    Type: String
    AllowedValues: [Enabled, Disabled]
    Default: Enabled
  EKSClusterLoggingTypes:
    Type: List<String>
    Default: ""
  EKSEncryptSecrets:
    Type: String
    AllowedValues: [Enabled, Disabled]
    Default: Enabled
  EKSEncryptSecretsKmsKeyArn:
    Type: String
    Default: ""
  IamOidcProvider:
    Type: String
    AllowedValues: [ "Enabled", "Disabled" ]
    Default: "Enabled"
  EKSClusterName:
    Type: String
  #ConfigSetName:
  #  Type: String
Conditions:
  # Cisco - custom node role support
  CustomeNodeRoleProvided: !Not [ !Equals [ !Ref CustomNodeRole, "" ] ]
  # end

  AddUser: !Not [ !Equals [ !Ref AdditionalEKSAdminUserArn, "" ] ]
  AddRole: !Not [ !Equals [ !Ref AdditionalEKSAdminRoleArn, "" ] ]
  BastionRole: !Not [ !Equals [ !Ref BastionRole, "" ] ]
  EnablePrivateEndpoint: !Equals [ !Ref EKSPrivateAccessEndpoint, "Enabled" ]
  EnablePublicEndpoint: !Equals [ !Ref EKSPublicAccessEndpoint, "Enabled" ]
  CreateKey: !And
    - !Equals [ !Ref EKSEncryptSecretsKmsKeyArn, "" ]
    - !Equals [ !Ref EKSEncryptSecrets, Enabled ]
  EnableEncryption: !Equals [ !Ref EKSEncryptSecrets, Enabled ]
  LoggingEnabled: !Not [ !Equals [ !Select [ 0, !Ref EKSClusterLoggingTypes ], "" ] ]
  EnableIamOidcProvider: !Equals [!Ref 'IamOidcProvider', 'Enabled']
Mappings:
  Config:
    Prefix: { Value: 'eks-quickstart' }
Resources:
  KMSKey:
    Condition: CreateKey
    Type: "AWS::KMS::Key"
    Metadata:
      cfn-lint:
        config:
          ignore_checks: [EIAMPolicyActionWildcard, EKMSKeyEnableKeyRotation]
          ignore_reasons:
            EKMSKeyEnableKeyRotation: 'Need to experiment further with the effets of rotating keys and EKS secrets'
            EIAMPolicyWildcardResource: 'this is the default kms policy as per https://docs.aws.amazon.com/kms/latest/developerguide/key-policies.html#key-policy-default'
    Properties:
      KeyPolicy: {
        "Version": "2012-10-17",
        "Id": "key-default-1",
        "Statement": [
          {
            "Sid": "Enable IAM User Permissions",
            "Effect": "Allow",
            "Principal": {
              "AWS": !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:root"
            },
            "Action": "kms:*",
            "Resource": "*"
          }
        ]
      }
  EKS:
    Type: "AWSQS::EKS::Cluster"
    DependsOn: CleanupLoadBalancers
    Properties:
      Name: !Ref EKSClusterName
      ResourcesVpcConfig:
        SecurityGroupIds: !Ref SecurityGroupIds
        SubnetIds: !Ref SubnetIds
        PublicAccessCidrs: !Ref EKSPublicAccessCIDRs
        EndpointPrivateAccess: !If [ EnablePrivateEndpoint, true, false ]
        EndpointPublicAccess: !If [ EnablePublicEndpoint, true, false ]
      EnabledClusterLoggingTypes: !If [ LoggingEnabled, !Ref EKSClusterLoggingTypes, !Ref "AWS::NoValue" ]
      EncryptionConfig: !If
        - EnableEncryption
        - - Resources: [ secrets ]
            Provider:
              KeyArn: !If [ CreateKey, !GetAtt KMSKey.Arn, !Ref EKSEncryptSecretsKmsKeyArn ]
        - !Ref AWS::NoValue
      RoleArn: !Ref RoleArn
      Version: !Ref KubernetesVersion
      KubernetesApiAccess:
        Roles:
          # Cisco - The node role was customized to support a custom node role. The original line is:
          # - Arn: !Sub ['arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${Prefix}-UnmanagedNodeInstance', {Prefix: !FindInMap [Config, Prefix, Value]}]
          # Custom node role support
          - Arn: !Sub
              - 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${NodeRole}'
              - NodeRole: !If
                  - CustomeNodeRoleProvided
                  - !Ref CustomNodeRole
                  - !Sub [ '${Prefix}-UnmanagedNodeInstance', { Prefix: !FindInMap [ Config, Prefix, Value ] } ]
            Username: 'system:node:{{EC2PrivateDNSName}}'
            Groups: [ 'system:bootstrappers', 'system:nodes', 'eks:kube-proxy-windows' ]
          # end

          - Arn: !Ref FunctionRoleArn
            Username: !Ref FunctionRoleArn
            Groups: [ 'system:masters' ]
          - Arn: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/awsqs-kubernetes-helm"
            Username: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/awsqs-kubernetes-helm"
            Groups: [ 'system:masters' ]
          - Arn: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/awsqs-kubernetes-get"
            Username: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/awsqs-kubernetes-get"
            Groups: [ 'system:masters' ]
          - Arn: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/awsqs-kubernetes-resource"
            Username: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/awsqs-kubernetes-resource"
            Groups: [ 'system:masters' ]
          # We don't know whether GetCallerArn returned a user arn or a role arn, so we just add it to both
          - Arn: !GetAtt CallerArn.Arn
            Username: !GetAtt CallerArn.Arn
            Groups: [ 'system:masters' ]
          - !If
            - BastionRole
            - Arn: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${BastionRole}"
              Username: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${BastionRole}"
              Groups: [ 'system:masters' ]
            - !Ref 'AWS::NoValue'
          - !If
            - AddRole
            - Arn: !Ref AdditionalEKSAdminRoleArn
              Username: !Ref AdditionalEKSAdminRoleArn
              Groups: [ 'system:masters' ]
            - !Ref 'AWS::NoValue'
        Users:
          # We don't know whether GetCallerArn returned a user arn or a role arn, so we just add it to both
          - Arn: !GetAtt CallerArn.Arn
            Username: !GetAtt CallerArn.Arn
            Groups: [ 'system:masters' ]
          - !If
            - AddUser
            - Arn: !Ref AdditionalEKSAdminUserArn
              Username: !Ref AdditionalEKSAdminUserArn
              Groups: [ 'system:masters' ]
            - !Ref 'AWS::NoValue'
  CleanupLoadBalancers:
    Type: Custom::CleanupLoadBalancers
    Properties:
      ServiceToken: !Sub ['arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${Prefix}-CleanupLoadBalancers', {Prefix: !FindInMap [Config, Prefix, Value]}]
      ClusterName: !Ref EKSClusterName
  CallerArn:
    Type: Custom::GetCallerArn
    Properties:
      ServiceToken: !Sub ['arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${Prefix}-GetCallerArn', {Prefix: !FindInMap [Config, Prefix, Value]}]

  # Cisco - ClusterOIDCProvider renamed to ClusterOIDCProviderNew for upgrade compatibility.
  # Without this, AWS errors out during upgrade with: "Update of resource type is not permitted. The new template modifies resource type of the following resources: [ClusterOIDCProvider]"
  # Also, the original ClusterOIDCProvider is left just for the deletion purposes (because only one instance can exist).
  # Lines 214-273 can be removed in SFCN v1.1+ releases.
  ClusterOIDCProviderNew:
    Condition: EnableIamOidcProvider
    Metadata:
      DependsOn:
        - !If [ EnableIamOidcProvider, !Ref ClusterOIDCProvider, !Ref "AWS::NoValue" ]
    Type: AWS::IAM::OIDCProvider
    Properties:
      ClientIdList:
        - sts.amazonaws.com
      ThumbprintList:
        - 9e99a48a9960b14926bb7f3b02e22da2b0ab7280
      Url: !GetAtt EKS.OIDCIssuerURL

  ClusterOIDCProvider:
    Condition: EnableIamOidcProvider
    Type: Custom::ClusterOIDCProvider
    Properties:
      ServiceToken: !GetAtt ClusterOIDCProviderFunction.Arn
      OIDCIssuerURL: !GetAtt EKS.OIDCIssuerURL
  ClusterOIDCProviderFunction:
    Condition: EnableIamOidcProvider
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.7
      Handler: index.lambda_handler
      MemorySize: 128
      Role: !GetAtt ClusterOIDCLambdaExecutionRole.Arn
      Timeout: 30
      Code:
        ZipFile: |
          import boto3
          from botocore.exceptions import ClientError
          import json
          import cfnresponse
          iam = boto3.client("iam")
          def lambda_handler(event, context):
            data = {}
            try:
              oidc_issuer_url = event['ResourceProperties']['OIDCIssuerURL']
              provider_arn = event["PhysicalResourceId"]
              if event['RequestType'] == 'Update' or event['RequestType'] == 'Delete':
                if provider_arn is None:
                  data["Reason"] = "Provider not present"
                else:
                  iam.delete_open_id_connect_provider(OpenIDConnectProviderArn=provider_arn)
                  data["Reason"] = "Provider with ARN " + provider_arn + " deleted"
              cfnresponse.send(event, context, cfnresponse.SUCCESS, data, provider_arn or context.log_stream_name)
            except Exception as e:
              data["Reason"] = "Cannot delete Provider" + str(e)
              cfnresponse.send(event, context, cfnresponse.FAILED, data, "")
  ClusterOIDCLambdaExecutionRole:
    Condition: EnableIamOidcProvider
    Type: AWS::IAM::Role
    Properties:
      Path: /
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: root
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - iam:DeleteOpenIDConnectProvider
                Resource: !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:oidc-provider/*"
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:${AWS::Partition}:logs:*:*:*"

Outputs:
  EksArn:
    Value: !GetAtt EKS.Arn
  CAData:
    Value: !GetAtt EKS.CertificateAuthorityData
  EKSEndpoint:
    Value: !GetAtt EKS.Endpoint
  OIDCIssuerURL:
    Value: !GetAtt EKS.OIDCIssuerURL
  EKSName:
    Value: !Ref EKS
